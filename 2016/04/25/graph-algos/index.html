<!DOCTYPE html>
<html lang="cn">

<head>
      <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>可视化图的基本算法</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="http://blog.rainy.im/" rel="canonical" />

  <!-- Feed -->
        <link href="http://blog.rainy.im/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Yu's Tech Lab Full Atom Feed" />
          <link href="http://blog.rainy.im/feeds/python.atom.xml" type="application/atom+xml" rel="alternate" title="Yu's Tech Lab Categories Atom Feed" />

  <link href="http://blog.rainy.im/theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="http://blog.rainy.im/theme/css/code_blocks/github.css" rel="stylesheet">


  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


    <link href="http://blog.rainy.im/2016/04/25/graph-algos/" rel="canonical" />

        <meta name="description" content="关于图的基本表示与基本算法，包括图的邻接表和邻接矩阵表示法；图的广度优先（BFS）与深度优先（DFS）搜索算法；最小权生成树问题的 Kruskal 算法与 Prim 算法；单源最短路径的 Dijkstra 算法。">

        <meta name="author" content="Yusheng">

        <meta name="tags" content="Python">
        <meta name="tags" content="算法">




<!-- Open Graph -->
<meta property="og:site_name" content="Yu's Tech Lab"/>
<meta property="og:title" content="可视化图的基本算法"/>
<meta property="og:description" content="关于图的基本表示与基本算法，包括图的邻接表和邻接矩阵表示法；图的广度优先（BFS）与深度优先（DFS）搜索算法；最小权生成树问题的 Kruskal 算法与 Prim 算法；单源最短路径的 Dijkstra 算法。"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://blog.rainy.im/2016/04/25/graph-algos/"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2016-04-25 13:51:22+08:00"/>
<meta property="article:modified_time" content="2016-04-25 13:51:22+08:00"/>
<meta property="article:author" content="http://blog.rainy.im/author/yusheng.html">
<meta property="article:section" content="Python"/>
<meta property="article:tag" content="Python"/>
<meta property="article:tag" content="算法"/>
<meta property="og:image" content="http://blog.rainy.im/theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "可视化图的基本算法",
  "headline": "可视化图的基本算法",
  "datePublished": "2016-04-25 13:51:22+08:00",
  "dateModified": "2016-04-25 13:51:22+08:00",
  "author": {
    "@type": "Person",
    "name": "Yusheng",
    "url": "http://blog.rainy.im/author/yusheng.html"
  },
  "image": "http://blog.rainy.im/theme/images/post-bg.jpg",
  "url": "http://blog.rainy.im/2016/04/25/graph-algos/",
  "description": "关于图的基本表示与基本算法，包括图的邻接表和邻接矩阵表示法；图的广度优先（BFS）与深度优先（DFS）搜索算法；最小权生成树问题的 Kruskal 算法与 Prim 算法；单源最短路径的 Dijkstra 算法。"
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="post-header" class="has-cover">
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="http://blog.rainy.im/" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">可视化图的基本算法</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="http://blog.rainy.im/author/yusheng.html">Yusheng</a>
            | <time datetime="Mon 25 April 2016">Mon 25 April 2016</time>
        </span>
        <!-- TODO : Modified check -->
            <span class="post-meta"> | Updated on Mon 25 April 2016</span>
            <div class="post-cover cover" style="background-image: url('http://blog.rainy.im/theme/images/post-bg.jpg')">
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h3>0. About</h3>
<p>关于图的基本表示与基本算法，包括图的邻接表和邻接矩阵表示法；图的广度优先（BFS）与深度优先（DFS）搜索算法；最小权生成树问题的 Kruskal 算法与 Prim 算法；单源最短路径的 Dijkstra 算法。</p>
<h3>1. 邻接表与邻接矩阵表示</h3>
<p>邻接表表示法就是将图的每个节点保存在数组中，每个节点指向与之相邻的节点所组成的链表：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">GraphTable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">is_dir</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_dir</span> <span class="o">=</span> <span class="n">is_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dir</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Graph&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;circo&#39;</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;circle&#39;</span><span class="p">),</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">Digraph</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dir</span> <span class="k">else</span> <span class="n">Graph</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>
</pre></div>


<div class="highlight"><pre><span class="n">gt</span> <span class="o">=</span> <span class="n">GraphTable</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>
<span class="k">print</span><span class="p">(</span><span class="n">gt</span><span class="p">)</span>
<span class="n">gt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[1, 2, 5]</span>
<span class="sd">[2, 1, 5, 4, 3]</span>
<span class="sd">[3, 2, 4]</span>
<span class="sd">[4, 2, 5, 3]</span>
<span class="sd">[5, 1, 2, 4]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<p><img alt="邻接表无向图" src="http://qncdn.rainy.im/%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%97%A0%E5%90%91%E5%9B%BE.png"></p>
<div class="highlight"><pre><span class="n">dgt</span> <span class="o">=</span> <span class="n">GraphTable</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">is_dir</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">dgt</span><span class="p">)</span>
<span class="n">dgt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[1, 2, 5]</span>
<span class="sd">[2, 5, 4, 3]</span>
<span class="sd">[3, 4]</span>
<span class="sd">[4]</span>
<span class="sd">[5, 4]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<p><img alt="邻接表有向图" src="http://qncdn.rainy.im/%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%9C%89%E5%90%91%E5%9B%BE.png"></p>
<p>邻接矩阵表示法则是用一个 N 阶矩阵来表示，其中任意两个节点所对应的矩阵中的值为0或1表示两个节点是否相连通：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">GraphMatrix</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">is_dir</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dir</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">]))</span>
</pre></div>


<div class="highlight"><pre><span class="n">gm</span> <span class="o">=</span> <span class="n">GraphMatrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>
<span class="k">print</span><span class="p">(</span><span class="n">gm</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[0, 1, 0, 0, 1]</span>
<span class="sd">[1, 0, 1, 1, 1]</span>
<span class="sd">[0, 1, 0, 1, 0]</span>
<span class="sd">[0, 1, 1, 0, 1]</span>
<span class="sd">[1, 1, 0, 1, 0]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<div class="highlight"><pre><span class="n">dgm</span> <span class="o">=</span> <span class="n">GraphMatrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">is_dir</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">dgm</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[0, 1, 0, 0, 1]</span>
<span class="sd">[0, 0, 1, 1, 1]</span>
<span class="sd">[0, 0, 0, 1, 0]</span>
<span class="sd">[0, 0, 0, 0, 0]</span>
<span class="sd">[0, 0, 0, 1, 0]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<p>这两种表示方法都可以很容易地扩展为加权图，对于比较稀疏的图（定点数远大于边的数量）通常采用邻接表表示法，后面涉及到的算法均采用邻接表表示法。</p>
<h3>2. 广度优先搜索与深度优先搜索</h3>
<p>广度优先搜索就是按层遍历树时用到的思想，即先尽可能多地访问直接相连的节点，再向深处延伸，因此需要使用队列存储访问过的节点。</p>
<div class="highlight"><pre><span class="c1"># 定义一个枚举类型，用于标记访问过的节点的状态</span>
<span class="c1"># WHITE 表示未查看过</span>
<span class="c1"># GRAY 表示查看过但未访问</span>
<span class="c1"># BLACK 表示已经访问过</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">WHITE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">GRAY</span>  <span class="o">=</span> <span class="mi">1</span>
    <span class="n">BLACK</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>


<div class="highlight"><pre><span class="c1"># 需要向 GraphTable 添加方法 adjs 用于</span>
<span class="c1"># 查询所有与某节点直接相连的节点</span>
<span class="k">def</span> <span class="nf">adjs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">color</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">parent</span><span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
        <span class="n">color</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span>
        <span class="n">dists</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span> <span class="bp">None</span>
    <span class="n">color</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GRAY</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjs</span><span class="p">(</span><span class="n">cursor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">:</span>
                <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GRAY</span>
                <span class="n">dists</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">cursor</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">color</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;[{}] visited!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cursor</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">parent</span>
</pre></div>


<p>返回的 <code>parent</code> 保存了每个被访问节点的上一个节点，可以通过递归找出访问路径：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">visit</span><span class="p">,</span> <span class="n">search</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">):</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">visit_path</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">visit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">visit</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;No path from {} to {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">visit_path</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">visit</span><span class="p">)</span>
            <span class="n">visit</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">visit_path</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">visit</span><span class="p">)</span>
<span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">shortest_path</span><span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[1] visited!</span>
<span class="sd">[2] visited!</span>
<span class="sd">[5] visited!</span>
<span class="sd">[4] visited!</span>
<span class="sd">[3] visited!</span>
<span class="sd">[1, 2, 3]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<p>深度优先搜索则是先尽可能深远地搜索每一个相连通的节点，因此可以使用栈结构或递归的方式进行搜索：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">visit</span><span class="o">=</span><span class="k">print</span><span class="p">):</span>
    <span class="n">color</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
        <span class="n">color</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span>
    <span class="k">def</span> <span class="nf">DFS_visit</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">color</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GRAY</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">:</span>
                <span class="n">DFS_visit</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">color</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span>
        <span class="n">visit</span><span class="p">(</span><span class="s2">&quot;[{}] visited!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
    <span class="n">DFS_visit</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">DFS</span><span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[3] visited!</span>
<span class="sd">[4] visited!</span>
<span class="sd">[5] visited!</span>
<span class="sd">[2] visited!</span>
<span class="sd">[1] visited!</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<h3>3. 最小生成树</h3>
<p>最小生成树实际上是“最小权值生成树”的缩写，与后面的单源最短路径问题一样，都是基于加权图的算法，因此需要先定义加权图的邻接表表示法：</p>
<div class="highlight"><pre><span class="c1"># 加权图</span>
<span class="k">class</span> <span class="nc">WeiGraph</span><span class="p">(</span><span class="n">GraphTable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">is_dir</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dir</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                        <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_dir</span> <span class="o">=</span> <span class="n">is_dir</span>
    <span class="k">def</span> <span class="nf">adjs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color_filter</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">color_filter</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">color_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Graph&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;circo&#39;</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;circle&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dir</span> <span class="k">else</span> <span class="n">Digraph</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color_filter</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>
</pre></div>


<div class="highlight"><pre><span class="n">wg</span> <span class="o">=</span> <span class="n">WeiGraph</span><span class="p">(</span><span class="s1">&#39;abcdefghi&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;h&#39;</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;h&#39;</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="mi">14</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="s1">&#39;h&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="mi">7</span><span class="p">)])</span>
<span class="k">print</span><span class="p">(</span><span class="n">wg</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[(&#39;a&#39;, 0), (&#39;b&#39;, 4), (&#39;h&#39;, 8)]</span>
<span class="sd">[(&#39;b&#39;, 0), (&#39;a&#39;, 4), (&#39;h&#39;, 11), (&#39;c&#39;, 8)]</span>
<span class="sd">[(&#39;c&#39;, 0), (&#39;b&#39;, 8), (&#39;d&#39;, 7), (&#39;f&#39;, 4), (&#39;i&#39;, 2)]</span>
<span class="sd">[(&#39;d&#39;, 0), (&#39;c&#39;, 7), (&#39;e&#39;, 9), (&#39;f&#39;, 14)]</span>
<span class="sd">[(&#39;e&#39;, 0), (&#39;d&#39;, 9), (&#39;f&#39;, 10)]</span>
<span class="sd">[(&#39;f&#39;, 0), (&#39;c&#39;, 4), (&#39;d&#39;, 14), (&#39;e&#39;, 10), (&#39;g&#39;, 2)]</span>
<span class="sd">[(&#39;g&#39;, 0), (&#39;f&#39;, 2), (&#39;h&#39;, 1)]</span>
<span class="sd">[(&#39;h&#39;, 0), (&#39;a&#39;, 8), (&#39;b&#39;, 11), (&#39;g&#39;, 1), (&#39;i&#39;, 7)]</span>
<span class="sd">[(&#39;i&#39;, 0), (&#39;c&#39;, 2), (&#39;h&#39;, 7)]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">wg</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>


<p><img alt="" src="http://qncdn.rainy.im/%E5%8A%A0%E6%9D%83%E6%97%A0%E5%90%91%E5%9B%BE.png"></p>
<p>最小生成树问题是指在给定的加权图中选择部分边，满足所有节点可以互相连通（即可以生成原有的图）同时所有边的权值之和最小。</p>
<p>Kruskal 算法首先将所有节点看作是一群孤立的树（即森林），然后将所有边按照权值存入优先队列，之后依次取出权值最小的边，并检查这个边的两个节点是否已经在同一棵树上，如果不是则将两点所在树合二为一。这里的森林和树通过集合进行操作。</p>
<div class="highlight"><pre><span class="c1"># 优先队列采用 Python 的 Queue.PriorityQueue</span>
<span class="c1"># 但由于图的边采用 (u, v, w) 的方式存储</span>
<span class="c1"># 而 PriorityQueue 只以第一个元素作为权值</span>
<span class="c1"># 因此需要稍作改动</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span> <span class="k">as</span> <span class="n">PQ</span>
<span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">(</span><span class="n">PQ</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">option</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">option</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># 用 集合 存储和操作森林与树</span>
<span class="k">class</span> <span class="nc">Forest</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">item</span><span class="p">}))</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_a</span><span class="p">,</span> <span class="n">item_b</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">item_a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">item_b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">item</span><span class="p">})):</span>
                <span class="k">return</span> <span class="n">s</span>
        <span class="k">return</span> <span class="bp">None</span>

<span class="c1"># Kruskal 算法</span>
<span class="k">def</span> <span class="nf">Kruskal</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">Tree</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">Forest</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">all_nodes</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">Tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="o">.</span><span class="n">union</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
            <span class="n">all_nodes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">Tree</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span class="n">tree</span> <span class="o">=</span> <span class="n">Kruskal</span><span class="p">(</span><span class="n">wg</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[(&#39;b&#39;, &#39;c&#39;, 8), (&#39;c&#39;, &#39;i&#39;, 2), (&#39;g&#39;, &#39;h&#39;, 1), (&#39;d&#39;, &#39;e&#39;, 9), (&#39;c&#39;, &#39;f&#39;, 4), (&#39;c&#39;, &#39;d&#39;, 7), (&#39;f&#39;, &#39;g&#39;, 2), (&#39;a&#39;, &#39;b&#39;, 4)]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<p>对结果中的边进行染色标记：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">cf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">color_filter</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
        <span class="n">in_tree</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">t</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">in_tree</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;red&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;black&#39;</span>
    <span class="k">return</span> <span class="n">color_filter</span>
<span class="n">wg</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">color_filter</span><span class="o">=</span><span class="n">cf</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>


<p><img alt="" src="http://qncdn.rainy.im/Kruskal.png"></p>
<p>Prim 算法与后面的 Dijkstra 算法有些类似，保存一个 <code>k[node]</code> 为 <code>node</code> 与最小生成树中所有节点之间最小权值，然后从起点开始，以 <code>k[node]</code> 为键存入优先队列，然后从队列中依次取出的最小元素，找到与树外相邻节点的最小权值，并将其纳入树中。</p>
<p>这里为区分树内树外可以直接检查优先队列，Python 中的优先队列实际上就是对最小堆的简单封装，本质上还是一个列表，因此我们可以直接利用 <code>heapq</code> 进行改造获得一个可查询的优先队列：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heapify</span>
<span class="k">class</span> <span class="nc">SearchQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)))</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="n">heapify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span class="k">def</span> <span class="nf">Prim</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 保存权值</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 保存上一个节点</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">SearchQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">k</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span>
        <span class="n">p</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">k</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">k</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">node</span><span class="p">))</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjs</span><span class="p">(</span><span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">queue</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">p</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">k</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span> 
                <span class="n">queue</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>


<div class="highlight"><pre><span class="n">parent</span> <span class="o">=</span> <span class="n">Prim</span><span class="p">(</span><span class="n">wg</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{&#39;a&#39;: None,</span>
<span class="sd"> &#39;b&#39;: &#39;a&#39;,</span>
<span class="sd"> &#39;c&#39;: &#39;b&#39;,</span>
<span class="sd"> &#39;d&#39;: &#39;c&#39;,</span>
<span class="sd"> &#39;e&#39;: &#39;d&#39;,</span>
<span class="sd"> &#39;f&#39;: &#39;c&#39;,</span>
<span class="sd"> &#39;g&#39;: &#39;f&#39;,</span>
<span class="sd"> &#39;h&#39;: &#39;g&#39;,</span>
<span class="sd"> &#39;i&#39;: &#39;c&#39;}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<p>返回结果为一颗父指针树，也可以基于此对边进行染色：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">cf</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">color_filter</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">parent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;red&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;black&#39;</span>
    <span class="k">return</span> <span class="n">color_filter</span>
<span class="n">wg</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">color_filter</span><span class="o">=</span><span class="n">cf</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
</pre></div>


<p><img alt="" src="http://qncdn.rainy.im/Prim.png"></p>
<h3>4. 单源最短路径问题</h3>
<p>单源最短路径问题是指从给定节点出发到剩余所有节点的加权最短路径，以加权有向图为例：</p>
<div class="highlight"><pre><span class="n">dwg</span> <span class="o">=</span> <span class="n">WeiGraph</span><span class="p">(</span><span class="s1">&#39;stxyz&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
                        <span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                        <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
                        <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                        <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">6</span><span class="p">)],</span> <span class="n">is_dir</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">dwg</span><span class="p">)</span>              
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[(&#39;s&#39;, 0), (&#39;t&#39;, 10), (&#39;y&#39;, 5)]</span>
<span class="sd">[(&#39;t&#39;, 0), (&#39;x&#39;, 1), (&#39;y&#39;, 2)]</span>
<span class="sd">[(&#39;x&#39;, 0), (&#39;z&#39;, 4)]</span>
<span class="sd">[(&#39;y&#39;, 0), (&#39;t&#39;, 3), (&#39;x&#39;, 9), (&#39;z&#39;, 2)]</span>
<span class="sd">[(&#39;z&#39;, 0), (&#39;s&#39;, 7), (&#39;x&#39;, 6)]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">dwg</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>


<p><img alt="" src="http://qncdn.rainy.im/%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE.png"></p>
<p>Dijkstra 算法同样从起点开始构建最短路径，将所有节点与最短路径之间的距离作为键值存入优先队列，依次选择队列中的最小值，并与所有邻接点进行比较，看是否通过该点将其纳入最短路径是权值最小的：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">Dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">SearchQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">dist</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">node</span><span class="p">))</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjs</span><span class="p">(</span><span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">w</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">dist</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">node</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">parent</span>
</pre></div>


<div class="highlight"><pre><span class="n">parent</span> <span class="o">=</span> <span class="n">Dijkstra</span><span class="p">(</span><span class="n">dwg</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{&#39;s&#39;: None, &#39;t&#39;: &#39;y&#39;, &#39;x&#39;: &#39;t&#39;, &#39;y&#39;: &#39;s&#39;, &#39;z&#39;: &#39;y&#39;}</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">cf</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">color_filter</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># 有向</span>
            <span class="k">return</span> <span class="s1">&#39;red&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;black&#39;</span>
    <span class="k">return</span> <span class="n">color_filter</span>
<span class="n">dwg</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">color_filter</span><span class="o">=</span><span class="n">cf</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
</pre></div>


<p><img alt="" src="http://qncdn.rainy.im/Dijkstra.png"></p>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=可视化图的基本算法&amp;url=http://blog.rainy.im/2016/04/25/graph-algos/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.rainy.im/2016/04/25/graph-algos/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=http://blog.rainy.im/2016/04/25/graph-algos/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="http://blog.rainy.im/tag/python.html">Python</a><a href="http://blog.rainy.im/tag/suan-fa.html">算法</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="http://blog.rainy.im/theme/js/script.js"></script>

</body>
</html>