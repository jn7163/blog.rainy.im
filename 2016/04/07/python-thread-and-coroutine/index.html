<!DOCTYPE html>
<html lang="cn">

<head>
      <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>Python 线程与协程</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="http://blog.rainy.im/" rel="canonical" />

  <!-- Feed -->
        <link href="http://blog.rainy.im/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Yu's Tech Lab Full Atom Feed" />
          <link href="http://blog.rainy.im/feeds/python.atom.xml" type="application/atom+xml" rel="alternate" title="Yu's Tech Lab Categories Atom Feed" />

  <link href="http://blog.rainy.im/theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="http://blog.rainy.im/theme/css/code_blocks/github.css" rel="stylesheet">


  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


    <link href="http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/" rel="canonical" />

        <meta name="description" content="要说到线程（Thread）与协程（Coroutine）似乎总是需要从并行（Parallelism）与并发（Concurrency）谈起，关于并行与并发的问题。">

        <meta name="author" content="Yusheng">

        <meta name="tags" content="Python">




<!-- Open Graph -->
<meta property="og:site_name" content="Yu's Tech Lab"/>
<meta property="og:title" content="Python 线程与协程"/>
<meta property="og:description" content="要说到线程（Thread）与协程（Coroutine）似乎总是需要从并行（Parallelism）与并发（Concurrency）谈起，关于并行与并发的问题。"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2016-04-07 15:34:05+08:00"/>
<meta property="article:modified_time" content="2016-04-07 15:34:05+08:00"/>
<meta property="article:author" content="http://blog.rainy.im/author/yusheng.html">
<meta property="article:section" content="Python"/>
<meta property="article:tag" content="Python"/>
<meta property="og:image" content="http://blog.rainy.im/theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Python 线程与协程",
  "headline": "Python 线程与协程",
  "datePublished": "2016-04-07 15:34:05+08:00",
  "dateModified": "2016-04-07 15:34:05+08:00",
  "author": {
    "@type": "Person",
    "name": "Yusheng",
    "url": "http://blog.rainy.im/author/yusheng.html"
  },
  "image": "http://blog.rainy.im/theme/images/post-bg.jpg",
  "url": "http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/",
  "description": "要说到线程（Thread）与协程（Coroutine）似乎总是需要从并行（Parallelism）与并发（Concurrency）谈起，关于并行与并发的问题。"
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="post-header" class="has-cover">
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="http://blog.rainy.im/" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Python 线程与协程</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="http://blog.rainy.im/author/yusheng.html">Yusheng</a>
            | <time datetime="Thu 07 April 2016">Thu 07 April 2016</time>
        </span>
        <!-- TODO : Modified check -->
            <span class="post-meta"> | Updated on Thu 07 April 2016</span>
            <div class="post-cover cover" style="background-image: url('http://blog.rainy.im/theme/images/post-bg.jpg')">
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <p>选自：<a href="https://git.io/pytips">PyTips 0x12 &amp; 0x13</a></p>
<h3>线程</h3>
<p>要说到线程（Thread）与协程（Coroutine）似乎总是需要从并行（Parallelism）与并发（Concurrency）谈起，关于并行与并发的问题，<a href="https://talks.golang.org/2012/waza.slide#10">Rob Pike 用 Golang 小地鼠烧书的例子</a>给出了非常生动形象的说明。简单来说并行就是我们现实世界运行的样子，每个人都是独立的执行单元，各自完成自己的任务，这对应着计算机中的分布式（多台计算机）或多核（多个CPU）运作模式；而对于并发，我看到最生动的解释来自<a href="https://www.quora.com/What-are-the-differences-between-parallel-concurrent-and-asynchronous-programming">Quora 上 Jan Christian Meyer 回答的这张图</a>：</p>
<p><img alt="concurrency" src="http://qncdn.rainy.im/concurrency.jpeg"></p>
<p>并发对应计算机中充分利用单核（一个CPU）实现（看起来）多个任务同时执行。我们在这里将要讨论的 Python 中的线程与协程仅是基于单核的并发实现，随便去网上搜一搜（Thread vs Coroutine）可以找到一大批关于它们性能的争论、benchmark，这次话题的目的不在于讨论谁好谁坏，套用一句非常套路的话来说，抛开应用场景争好坏都是耍流氓。当然在硬件支持的条件下（多核）也可以利用线程和协程实现并行计算，而且 Python 2.6 之后新增了标准库 <code>multiprocessing</code> （<a href="https://www.python.org/dev/peps/pep-0371/">PEP 371</a>）突破了 GIL 的限制可以充分利用多核，但由于协程是基于单个线程的，因此多进程的并行对它们来说情况是类似的，因此这里只讨论单核并发的实现。</p>
<p>要了解线程以及协程的原理和由来可以查看参考链接中的前两篇文章。Python 3.5 中关于线程的标准库是 <code>threading</code>，之前在 2.x 版本中的 <code>thread</code> 在 3.x 之后更名为 <code>_thread</code> ，无论是2.7还是3.5都应该尽量避免使用较为底层的 <code>thread/_thread</code> 而应该使用 <code>threading</code>。</p>
<p>创建一个线程可以通过实例化一个 <code>threading.Thread</code> 对象：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Compute {} + {}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="k">def</span> <span class="nf">compute_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} + {} = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>    
<span class="n">threads</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">compute_sum</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span>
    <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">compute_sum</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
    <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">compute_sum</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span>
<span class="p">]</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Total elapsed time {} s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>

<span class="c1"># Do not use Thread</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">compute_sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">compute_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">compute_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Total elapsed time {} s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>Compute 0 + 0...
Compute 1 + 1...
Compute 2 + 2...
0 + 0 = 0
1 + 1 = 2
2 + 2 = 4
Total elapsed time 2.002729892730713 s
Compute 0 + 0...
0 + 0 = 0
Compute 1 + 1...
1 + 1 = 2
Compute 2 + 2...
2 + 2 = 4
Total elapsed time 6.004806041717529 s
</pre></div>


<p>除了通过将函数传递给 <code>Thread</code> 创建线程实例之外，还可以直接继承 <code>Thread</code> 类：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="k">class</span> <span class="nc">ComputeSum</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} + {} = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Compute {} + {}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> 
<span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">ComputeSum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">ComputeSum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">ComputeSum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Total elapsed time {} s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>Compute 0 + 0...
Compute 1 + 1...
Compute 2 + 2...
0 + 0 = 0
1 + 1 = 2
2 + 2 = 4
Total elapsed time 2.001662015914917 s
</pre></div>


<p>根据上面代码执行的结果可以发现，<code>compute_sum/t.run</code> 函数的执行是按照 <code>start()</code> 的顺序，但 <code>_sum</code> 结果的输出顺序却是随机的。因为 <code>_sum</code> 中加入了 <code>time.sleep(2.0)</code> ，让程序执行到这里就会进入阻塞状态，但是几个线程的执行看起来却像是同时进行的（并发）。</p>
<p>有时候我们既需要并发地“跳过“阻塞的部分，又需要有序地执行其它部分，例如操作共享数据的时候，这时就需要用到”锁“。在上述”求和线程“的例子中，假设每次求和都需要加上额外的 <code>_base</code> 并把计算结果累积到 <code>_base</code> 中。尽管这个例子不太恰当，但它说明了线程锁的用途：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Lock</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">_base</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ComputeSum</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} + {} + base = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Compute {} + {}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">_base</span>
        <span class="k">with</span> <span class="n">_lock</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">_base</span>
            <span class="n">_base</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>
<span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">ComputeSum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">ComputeSum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">ComputeSum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Total elapsed time {} s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>Compute 0 + 0...
Compute 1 + 1...
Compute 2 + 2...
0 + 0 + base = 1
1 + 1 + base = 3
2 + 2 + base = 7
Total elapsed time 2.0064051151275635 s
</pre></div>


<p>这里用<a href="https://github.com/rainyear/pytips/blob/master/Tips/2016-03-23-With-Context-Manager.ipynb">上下文管理器</a>来管理锁的获取和释放，相当于：</p>
<div class="highlight"><pre><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">_base</span>
    <span class="n">_base</span>  <span class="o">=</span> <span class="n">result</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>


<p><strong>死锁</strong></p>
<p>线程的一大问题就是通过加锁来”抢夺“共享资源的时候有可能造成死锁，例如下面的程序：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="n">_base_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
<span class="n">_pos_lock</span>  <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
<span class="n">_base</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c1"># Time 1</span>
    <span class="k">with</span> <span class="n">_base_lock</span><span class="p">:</span>
        <span class="c1"># Time 3</span>
        <span class="k">with</span> <span class="n">_pos_lock</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="k">def</span> <span class="nf">_minus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c1"># Time 0</span>
    <span class="k">with</span> <span class="n">_pos_lock</span><span class="p">:</span>
        <span class="c1"># Time 2</span>
        <span class="k">with</span> <span class="n">_base_lock</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>


<p>由于线程的调度执行顺序是不确定的，在执行上面两个线程 <code>_sum/_minus</code> 的时候就有可能出现注释中所标注的时间顺序，即 <code># Time 0</code> 的时候运行到 <code>with _pos_lock</code> 获取了 <code>_pos_lock</code> 锁，而接下来由于阻塞马上切换到了 <code>_sum</code> 中的 <code># Time 1</code> ，并获取了 <code>_base_lock</code>，接下来由于两个线程互相锁定了彼此需要的下一个锁，将会导致死锁，即程序无法继续运行。根据 <a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=403498894&amp;idx=2&amp;sn=219c1a6001b5bb7e6bdc7963b1af8450">我是一个线程</a> 中所描述的，为了避免死锁，需要所有的线程按照指定的算法（或优先级）来进行加锁操作。不管怎么说，死锁问题都是一件非常伤脑筋的事，原因之一在于不管线程实现的是并发还是并行，在编程模型和语法上看起来都是并行的，而我们的大脑虽然是一个（内隐的）绝对并行加工的机器，却非常不善于将并行过程具象化（至少在未经足够训练的时候）。而与线程相比，协程（尤其是结合事件循环）无论在编程模型还是语法上，看起来都是非常友好的单线程同步过程。后面第二部分我们再来讨论 Python 中协程是如何从”小三“一步步扶正上位的<code>:D</code>。</p>
<h3>协程</h3>
<p>我之前翻译了<a href="http://blog.rainy.im/2016/03/10/how-the-heck-does-async-await-work-in-python-3-5/">Python 3.5 协程原理</a>这篇文章之后尝试用了 <a href="https://github.com/rainyear/lolita/issues/28">Tornado + Motor</a> 模式下的协程进行异步开发，确实感受到协程所带来的好处（至少是语法上的<code>:D</code>）。至于协程的 <code>async/await</code> 语法是如何由开始的 <code>yield</code> 生成器一步一步上位至 Python 的 <code>async/await</code> 组合语句，前面那篇翻译的文章里面讲得已经非常详尽了。我们知道协程的本质上是：</p>
<blockquote>
<p>allowing multiple entry points for suspending and resuming execution at certain locations.</p>
</blockquote>
<p>允许多个入口对程序进行挂起、继续执行等操作，我们首先想到的自然也是生成器：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">jump_range</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="p">:</span>
        <span class="n">jump</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">index</span>
        <span class="k">if</span> <span class="n">jump</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">jump</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">jump</span>
<span class="n">jump</span> <span class="o">=</span> <span class="n">jump_range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>&lt;generator object jump_range at 0x10e283518&gt;
0
3
4
</pre></div>


<p>后来又新增了 <code>yield from</code> 语法，可以将生成器串联起来：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">wait_index</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="c1"># processing i...</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">yield</span> <span class="n">i</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">jump_range</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="p">:</span>
        <span class="n">jump</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">wait_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jump</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">jump</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">jump</span>
<span class="n">jump</span> <span class="o">=</span> <span class="n">jump_range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>&lt;generator object jump_range at 0x10e22a780&gt;
0
3
4
</pre></div>


<p><code>yield from</code>/<code>send</code> 似乎已经满足了协程所定义的需求，最初也确实是用 <a href="https://hg.python.org/cpython/file/3.5/Lib/types.py#l206"><code>@types.coroutine</code> 修饰器</a>将生成器转换成协程来使用，在 Python 3.5 之后则以专用的 <code>async/await</code> 取代了 <code>@types.coroutine/yield from</code>：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Wait</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    由于 Coroutine 协议规定 await 后只能跟 awaitable 对象，</span>
<span class="sd">    而 awaitable 对象必须是实现了 __await__ 方法且返回迭代器</span>
<span class="sd">    或者也是一个协程对象，</span>
<span class="sd">    因此这里临时实现一个 awaitable 对象。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">def</span> <span class="nf">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">jump_range</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="p">:</span>
        <span class="n">jump</span> <span class="o">=</span> <span class="n">await</span> <span class="n">Wait</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jump</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">jump</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">jump</span>
<span class="n">jump</span> <span class="o">=</span> <span class="n">jump_range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">jump</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>&lt;coroutine object jump_range at 0x10e2837d8&gt;
0
3
4
</pre></div>


<p><strong>与线程相比</strong></p>
<p>协程的执行过程如下所示：</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">types</span>

<span class="nd">@types.coroutine</span>
<span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Compute {} + {}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">yield</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="nd">@types.coroutine</span>
<span class="k">def</span> <span class="nf">compute_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} + {} = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">compute_sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>Compute 0 + 0...
0 + 0 = 0
</pre></div>


<p><img alt="tulip_coro" src="http://qncdn.rainy.im/tulip_coro.png"></p>
<p>这张图（来自: <a href="https://docs.python.org/3/library/asyncio-task.html">PyDocs: 18.5.3. Tasks and coroutines</a>）清楚地描绘了由事件循环调度的协程的执行过程，上面的例子中事件循环的队列里只有一个协程，如果要与上一部分中线程实现的并发的例子相比较，只要向事件循环的任务队列中添加协程即可：</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># 上面的例子为了从生成器过度，下面全部改用 async/await 语法</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Compute {} + {}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="n">async</span> <span class="k">def</span> <span class="nf">compute_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">await</span> <span class="n">_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{} + {} = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">compute_sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">compute_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">compute_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
<span class="p">]</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Total elapsed time {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>Compute 0 + 0...
Compute 1 + 1...
Compute 2 + 2...
0 + 0 = 0
1 + 1 = 2
2 + 2 = 4
Total elapsed time 2.0042951107025146
</pre></div>


<h3>总结</h3>
<p>这两篇主要关于 Python 中的线程与协程的一些基本原理与用法，为此我搜索了不少参考文章与链接，对我自己理解它们的原理与应用场景也有很大的帮助（当然也有可能存在理解不到位的地方，欢迎指正）。当然在这里还是主要关注基于 Python 的语法与应用，如果想要了解更多底层实现的细节，可能需要从系统调度等底层技术细节开始学习（几年前我记得翻阅过《深入理解LINUX内核》这本书，虽然大部分细节已经记不清楚了，但对于理解其它人的分析、总结还是有一定帮助的）。这里讨论的基于协程的异步主要是借助于事件循环（由<code>asyncio</code>标准库提供），包括上文中的示意图，看起来很容易让人联想到 <code>Node.js</code> 的事件循环 &amp; 回调，但是协程与回调也还是有区别的，具体就不在这里展开了，可以参考下面第一条参考链接。</p>
<h3>参考</h3>
<ol>
<li><a href="https://segmentfault.com/a/1190000001813992">Python 中的进程、线程、协程、同步、异步、回调</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=403498894&amp;idx=2&amp;sn=219c1a6001b5bb7e6bdc7963b1af8450">我是一个线程</a></li>
<li><a href="https://talks.golang.org/2012/waza.slide#1">Concurrency is not Parallelism</a></li>
<li><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf">A Curious Course on Coroutines and Concurrency</a></li>
<li><a href="https://docs.python.org/3.5/library/threading.html">PyDocs: 17.1. threading — Thread-based parallelism</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-task.html">PyDocs: 18.5.3. Tasks and coroutines</a></li>
<li><a href="http://blog.rainy.im/2016/03/10/how-the-heck-does-async-await-work-in-python-3-5/">[译] Python 3.5 协程究竟是个啥</a></li>
<li><a href="https://www.zhihu.com/question/20511233/answer/83307265">协程的好处是什么？ - crazybie 的回答</a></li>
<li><a href="http://python3-cookbook.readthedocs.org/zh_CN/latest/chapters/p12_concurrency.html">Py3-cookbook:第十二章：并发编程</a></li>
<li><a href="https://www.quora.com/What-are-the-differences-between-parallel-concurrent-and-asynchronous-programming">Quora: What are the differences between parallel, concurrent and asynchronous programming?</a></li>
<li><a href="http://learn-gevent-socketio.readthedocs.org/en/latest/index.html">Real-time apps with gevent-socketio</a></li>
</ol>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Python 线程与协程&amp;url=http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="http://blog.rainy.im/tag/python.html">Python</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="http://blog.rainy.im/theme/js/script.js"></script>

</body>
</html>